<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />

    <title>Manejo de Archivos en GO</title>
    <link rel="shortcut icon" href="./favicon.ico" />
    <link rel="stylesheet" href="./dist/reset.css" />
    <link rel="stylesheet" href="./dist/reveal.css" />
    <link rel="stylesheet" href="./dist/theme/solarized.css" id="theme" />
    <link rel="stylesheet" href="./css/highlight/base16/zenburn.css" />

    <link rel="stylesheet" href="./_assets/slides/css/filminas.css" />
  </head>
  <body>
    <div class="reveal">
      <div class="slides">
        <section data-markdown data-separator="^---" data-separator-vertical="^\r?\n----\r?\n$">
          <textarea data-template>
            

<style>
h1 {
  background-color: rgba(255,255,255,.7);
}
</style>

<section data-background-image="images/go/background.jpeg">

<br><br><br><br><br><br>

<h1> Manejo de Archivos</h1>

</section>

---

## Temario

- Defer
- Crear un archivo
- Escribir un archivo
- Leer un archivo

---

## Defer

Aplaza la ejecución de una función hasta que finaliza la función que la rodea. Se utiliza para garantizar que se realicen acciones de limpieza al terminar una función.

Usos de defer:

- Gestionar recursos
- Garantizar que las acciones de limpieza se realicen al finalizar una función
- Intercalar diferir correctamente al llamar a funciones que devuelven un error

---

## Defer

```go []
func main(){
	defer fmt.Println(3)
	fmt.Println(1)
	fmt.Println(2)
}
```

---

## Manejo de Archivos

Se realiza mediante paquetes y funciones que permiten leer, escribir y recorrer directorios.

---

## Manejo de Archivos

Crear un archivo en Go.

```go []
const path = "hola.txt"

func CreateFile(path string) error {
  file, err := os.Create(path)
  defer file.Close()

  if err != nil {
     return err
  }

  return nil
}
```

---

## Escribir un Archivo: WriteFile

<!-- .slide: style="font-size: 0.90em" -->

```go []
func WriteFile(path string, content []byte) error {
  if err := os.WriteFile(path, content, os.ModeAppend); err != nil {
     return err
  }
  return nil
}
```

Ejemplo:

```go []
data := []byte("Hola mundo!")
err := os.WriteFile("archivo.txt", data, 0644)
//0644 el propietario puede leer-escribir - otros usuarios solo lectura
```

- Crea o sobreescribe el archivo.
- Escribe todos los datos que se envien como parámetro.
- Cierra el archivo automáticamente.

---

## Escribir un Archivo: Write

```go []
file, err := os.Create("archivo.txt")
defer file.Close()
_, err = file.Write([]byte("Hola mundo"))
```

- Se requiere abrir o crear el archivo primero (os.Open, os.Create, etc.).
- Ofrece más control: se puede escribir en varias partes del archivo, usar **Seek** para moverse dentro del archivo, escribir en **chunks**, etc.

---

## Escribir un Archivo

<table>
<thead>
  <tr>
  <th></th>
  <th>os.WriteFile</th>
  <th>Write</th>
  </tr>
</thead>
<tbody>
<tr>
  <td>
  PROS
  </td>
  <td>
   <li>Simple para archivos pequeños. </li>
   <li>No es necesario abrir ni cerrar el archivo manualmente.</li>
  </td>
  <td>
  <li>Ofrece más control (ej. escribir en varias partes) </li>
  <li>Para archivos grandes o escritura continua </li>
  <li>Se puede escribir en diferentes posiciones del archivo</li>
  </td>
</tr>
<tr>
  <td>
  CONS
  </td>
  <td>
  <li>No es eficiente para escribir grandes volúmenes de datos o escribir por partes (streams). </li>
  <li>No se pueden hacer varias escrituras seguidas fácilmente.</li>
  </td>
  <td>
  <li>Se debe abrir y cerrar el archivo manualmente. </li> 
  <li>Ligeramente más código. </li>
  </td>
</tr>
</tbody>
</table>

---

## Lectura de archivos

<!-- .slide: style="font-size: 0.80em" -->

```go []
func readFile(path string) ([]byte, error) {

  file, err := os.Open(path)
  if err != nil {
     return nil, err
  }

  defer func() {
     err = file.Close()
     if err != nil {
        log.Fatal(err)
     }
  }() //Se agregan parentesis para que se ejecute la función

  bytes, err := ioutil.ReadAll(file)
  if err != nil {
     return nil, err
  }

  return bytes, nil
}
```

---

### Ejercicio 6: Gestor de Contactos

<!-- .slide: style="font-size: 0.70em" -->

Crear un programa que permita gestionar contactos: agregar, editar, eliminar.

- Los **contactos** deben poseer: nombre, email y teléfono (**struc**).
- Los contactos se deben almacenar en un archivo **json**.

Ejemplo de salida de pantalla:

```bash
==== GESTOR DE CONTACTOS ====
1. Agregar un contacto
2. Mostrar todos los contactos
3. Salir
Elige una opción: 1
Nombre: Agus
Email: agus@email.com
Phone: 3513892288
```

Ejemplo de archivo **json**:

```bash
[
  {
    "name": "Agus",
    "e-mail": "agus@email.com",
    "phone": "3513892288"
  }
]
```

---

## ¿Dudas, Preguntas, Comentarios?

![Preguntas](images/pregunta.gif)

          </textarea>
        </section>
      </div>
    </div>

    <script src="./dist/reveal.js"></script>

    <script src="./mermaid/dist/mermaid.min.js"></script>

    <script src="./plugin/markdown/markdown.js"></script>
    <script src="./plugin/highlight/highlight.js"></script>
    <script src="./plugin/zoom/zoom.js"></script>
    <script src="./plugin/notes/notes.js"></script>
    <script src="./plugin/math/math.js"></script>
    <script>
      function extend() {
        var target = {};
        for (var i = 0; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source) {
            if (source.hasOwnProperty(key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      }

      // default options to init reveal.js
      var defaultOptions = {
        controls: true,
        progress: true,
        history: true,
        center: true,
        transition: 'default', // none/fade/slide/convex/concave/zoom
        slideNumber: true,
        highlight: {
          highlightOnLoad: false
        },
        plugins: [
          RevealMarkdown,
          RevealHighlight,
          RevealZoom,
          RevealNotes,
          RevealMath
        ]
      };

      // options from URL query string
      var queryOptions = Reveal().getQueryHash() || {};

      var options = extend(defaultOptions, {"controls":true,"progress":true,"slideNumber":true,"_":["slides"],"static":"public"}, queryOptions);
    </script>

    <script src="./_assets/slides/js/pruebas.js"></script>
    <script src="./_assets/slides/js/init.js"></script>

    <script>
      Reveal.initialize(options);
      Reveal.addEventListener('ready', function (event) {
        const blocks = Reveal.getRevealElement().querySelectorAll('pre code:not(.mermaid)');
        const hlp = Reveal.getPlugin('highlight');
        blocks.forEach(hlp.highlightBlock);
      });
    </script>

    <script>
      const mermaidOptions = extend({ startOnLoad: false }, {});
      mermaid.startOnLoad = false;
      mermaid.initialize(mermaidOptions);
      const cb = function (event) {
        mermaid.init(mermaidOptions, '.stack.present > .present pre code.mermaid');
        mermaid.init(mermaidOptions, '.slides > .present:not(.stack) pre code.mermaid');
      }
      Reveal.addEventListener('ready', cb);
      Reveal.addEventListener('slidetransitionend', cb);
    </script>
  </body>
</html>
