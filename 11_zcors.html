<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />

    <title>Frontend - Node + React</title>
    <link rel="shortcut icon" href="./favicon.ico" />
    <link rel="stylesheet" href="./dist/reset.css" />
    <link rel="stylesheet" href="./dist/reveal.css" />
    <link rel="stylesheet" href="./dist/theme/solarized.css" id="theme" />
    <link rel="stylesheet" href="./css/highlight/base16/zenburn.css" />

    <link rel="stylesheet" href="./_assets/slides/css/filminas.css" />
  </head>
  <body>
    <div class="reveal">
      <div class="slides">
        <section data-markdown data-separator="^---" data-separator-vertical="^\r?\n----\r?\n$">
          <textarea data-template>
            

# Frontend - Node + React

<style>
h1 {
  background-color: rgba(255,255,255,.7);
}

.small{
	font-size: 0.2em
}
</style>

---

## Temario
- Cors

---

### CORS

CORS (Cross-Origin Resource Sharing) es un mecanismo de seguridad que implementan los navegadores para controlar qué recursos pueden ser accedidos desde otro origen.
Por ejemplo: El frontend en localhost:3000 intenta hacer una petición fetch() a un backend en localhost:8080. Aunque parezca el mismo host, el puerto cambia, entonces el navegador lo considera un "origen cruzado" y bloquea la petición a menos que el backend diga que lo permite.

---

### Configurar CORS en GO

Cuando se agrega esto en el handler o middleware:
- c.Header("Access-Control-Allow-Origin", "*")
- c.Header("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS")
- c.Header("Access-Control-Allow-Headers", "Content-Type, Authorization")

Estás diciéndole al navegador:
- **Allow-Origin:** "Cualquier frontend puede acceder a mi backend" (ideal para desarrollo).
- **Allow-Methods:** "Permití estos métodos HTTP".
- **Allow-Headers:** "Permití que vengan estos headers" (como Content-Type, Authorization, etc)

---

### Documentación de una API

Las **APIS** tienen disponible documentos donde se especifica cómo interactuar con ellas para enviar y recibir datos.

---

### Documentación de una API

<!-- .slide: style="font-size: 0.80em" -->

Para consumir una API necesitamos conocer:

- El método **HTTP** (GET, POST, PUT, DELETE, etc.)
- Las URL, que están conformadas por:
  - **Base URL:** Es la ruta básica a partir de la cual se forman todos los endpoints disponibles para consumir. Por ej. [http://api.mercadolibre.com/](http://api.mercadolibre.com/)
  - **Endpoint:** Es el path dentro de la API para acceder al recurso solicitado. Por ej. [/sites/MLA/categories]()
  - **Parámetros:** Son un conjunto de valores que se envían en la misma dirección. Se especifican mediante nombre=valor y se separan mediante el caracter &.
- El cuerpo del mensaje, llamado **body**.
- Las cabeceras del mensaje, llamados **headers**.

---

## Paquete HTTP

El paquete HTTP nos permite realizar peticiones y procesar los datos correspondientes a una solicitud HTTP, además de contar con variables, constantes y funciones útiles en este procesamiento. Para utilizarlo, debemos:

Importar el paquete HTTP:

```go
import "net/http"
```

---

## Paquete HTTP

<!-- .slide: style="font-size: 0.80em" -->

Invocar a la función correspondiente mediante http. Métodos básicos:

- **GET**

```go
resp := http.Get(url)
```

- **POST**

```go
resp := http.Get(url, body)
```

Luego, debemos leer los bytes de esta respuesta mediante:

```go
data, err := ioutil.ReadAll(resp.Body)
```

---

## Paquete HTTP

Una vez obtenidos los bytes, debemos crear una variable del tipo de dato que estamos esperando recibir.

```go
var myVar myStruct
```

Ahora debemos asociar toda la información contenida en el cuerpo de mensaje con nuestra estructura. Para esto, debemos tener en cuenta las anotaciones especificadas a la derecha de cada uno de los atributos de nuestra estructura e invocar un método del paquete encoding/json.

---

## Paquete ENCODING/JSON

El paquete ENCODING/JSON nos disponibiliza un gran número de funciones y útiles para trabajar con datos en formato json.
Para consumir una API, debemos desplegar, o asociar los datos obtenidos en una variable del tipo deseado. Para esto se utiliza la función **unmarshal** de la siguiente manera:

```go
err := json.Unmarshal(bytes, &myVar)
```

---

## Paquete ENCODING/JSON

Donde bytes, es el conjunto de bytes que leímos de la response y &myVar es la dirección de memoria del objeto creado anteriormente que se rellenará con los datos mediante las notations.

Si en este punto no obtenemos ningún error, entonces ya podríamos acceder a los valores de los atributos de nuestra variable tal como nos llegaron en el cuerpo de la respuesta a nuestra solicitud.

---

## Arquitectura web

![Arquitectura Web](images/react/arquitetcura.png)

---

## Frontend

- Descargar e instalar NodeJS desde https://nodejs.org/en/download
- Ir a la carpeta de la materia _/frontend_
- Ejecutar

```bash
npx create-react-app client
```

---

## Conectar frontend con backend

- Completar la vista del ítem
- Crear la carpeta frontend/server
  - Package.JSON
  - Server.JS
- Implementar la llamada a localhost:5001 en **useEffect** del componente

---

## Conexión frontend con backend

![Conexion Front-Back](images/react/conexion-front-back.png)

---

## ¿Dudas, Preguntas, Comentarios?

![Preguntas](images/pregunta.gif)

          </textarea>
        </section>
      </div>
    </div>

    <script src="./dist/reveal.js"></script>

    <script src="./mermaid/dist/mermaid.min.js"></script>

    <script src="./plugin/markdown/markdown.js"></script>
    <script src="./plugin/highlight/highlight.js"></script>
    <script src="./plugin/zoom/zoom.js"></script>
    <script src="./plugin/notes/notes.js"></script>
    <script src="./plugin/math/math.js"></script>
    <script>
      function extend() {
        var target = {};
        for (var i = 0; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source) {
            if (source.hasOwnProperty(key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      }

      // default options to init reveal.js
      var defaultOptions = {
        controls: true,
        progress: true,
        history: true,
        center: true,
        transition: 'default', // none/fade/slide/convex/concave/zoom
        slideNumber: true,
        highlight: {
          highlightOnLoad: false
        },
        plugins: [
          RevealMarkdown,
          RevealHighlight,
          RevealZoom,
          RevealNotes,
          RevealMath
        ]
      };

      // options from URL query string
      var queryOptions = Reveal().getQueryHash() || {};

      var options = extend(defaultOptions, {"controls":true,"progress":true,"slideNumber":true,"_":["slides"],"static":"public"}, queryOptions);
    </script>

    <script src="./_assets/slides/js/pruebas.js"></script>
    <script src="./_assets/slides/js/init.js"></script>

    <script>
      Reveal.initialize(options);
      Reveal.addEventListener('ready', function (event) {
        const blocks = Reveal.getRevealElement().querySelectorAll('pre code:not(.mermaid)');
        const hlp = Reveal.getPlugin('highlight');
        blocks.forEach(hlp.highlightBlock);
      });
    </script>

    <script>
      const mermaidOptions = extend({ startOnLoad: false }, {});
      mermaid.startOnLoad = false;
      mermaid.initialize(mermaidOptions);
      const cb = function (event) {
        mermaid.init(mermaidOptions, '.stack.present > .present pre code.mermaid');
        mermaid.init(mermaidOptions, '.slides > .present:not(.stack) pre code.mermaid');
      }
      Reveal.addEventListener('ready', cb);
      Reveal.addEventListener('slidetransitionend', cb);
    </script>
  </body>
</html>
