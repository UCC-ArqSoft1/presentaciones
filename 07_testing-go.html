<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />

    <title>Testing en GO</title>
    <link rel="shortcut icon" href="./favicon.ico" />
    <link rel="stylesheet" href="./dist/reset.css" />
    <link rel="stylesheet" href="./dist/reveal.css" />
    <link rel="stylesheet" href="./dist/theme/solarized.css" id="theme" />
    <link rel="stylesheet" href="./css/highlight/base16/zenburn.css" />

    <link rel="stylesheet" href="./_assets/slides/css/filminas.css" />
  </head>
  <body>
    <div class="reveal">
      <div class="slides">
        <section data-markdown data-separator="^---" data-separator-vertical="^\r?\n----\r?\n$">
          <textarea data-template>
            

# Testing en GO

---

## Temario

1. Concepto y utilidad del testing o pruebas de software
2. Tipos de testing
   - Por scope
   - Por visibilidad
3. Cómo implementar testing en Go
   - Librería testing
   - Librería assert
4. Cobertura

---

- Han realizado un proyecto?
- Como le aseguran al cliente que su proyecto funciona?
- Como aseguran que cumple con las funcionalidades requeridas por el cliente?

---

## Testing en Go

El testing en Go es un método para verificar si un producto digital cumple con los requisitos esperados y se encuentra libre de errores y brechas. El testing implica la ejecución de componentes de software utilizando herramientas manuales o automatizadas para evaluar una o más propiedades de interés.
Las pruebas de integración son una parte esencial del proceso de pruebas en Go, ya que proporcionan información valiosa sobre la funcionalidad general y el rendimiento de su aplicación a través de diferentes componentes.

---

## Testing en Go

Los diferentes tipos de pruebas en software son:

- Pruebas unitarias
- Pruebas de integración
- Pruebas funcionales
- Pruebas de extremo a extremo

---

## Concepto y utilidad de testing o pruebas de software

<!-- .slide: style="font-size: 0.80em" -->

- Las pruebas de software (en inglés software testing) son las investigaciones empíricas y técnicas cuyo objetivo es proporcionar información objetiva e independiente sobre la calidad del producto a la parte interesada o stakeholder. Es una actividad más en el proceso de control de calidad.
- El testing se puede realizar mediante pruebas estáticas (no requiere ejecución del software) y pruebas dinámicas (requieren ejecución del programa implementado).
- Librería para Golang: [https://github.com/stretchr/testify](https://github.com/stretchr/testify)

---

## Pruebas Unitarias

Una prueba unitaria es una forma de comprobar el correcto funcionamiento de una unidad de código.

```go []
func division(a int, b int) (int, error) {
	if b == 0 {
      return 0, errors.New(“no puedo dividir por 0”)}
	}
	return a / b, nil
}
```

---

## Pruebas Unitarias

<iframe width="560" height="315" src="https://www.youtube.com/embed/THUGSL6GM0g?si=qpYukAzrR5fUZTmx" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>

---

## Pruebas Funcionales

Una prueba funcional implica la ejecución de un servicio que está conectado con un conjunto de componentes externos.

```go []
func getUsuario(idUsuario int) *Usuario {
	if idUsuario == 0 {
      return nil
	}
	call := rest_client.Get(“api.mercadolibre/usuarios”)
	// ...
}
```

---

## Pruebas de Integración

Un test de integración hace referencia a una prueba de software donde se brindan un conjunto de entradas y se espera una salida sin conocer el proceso que ocurre internamente. También se conoce como test E2E.

Las pruebas de integración son esenciales en Go porque permiten comprobar cómo funcionan juntos los distintos componentes o módulos de una aplicación, garantizando que la funcionalidad general del software siga siendo fiable y esté libre de errores.

[https://api.mercadolibre.com/users/1234567](https://api.mercadolibre.com/users/1234567)

---

## Importancia de cada Test

Mientras mas test unitarios haga, mas seguridad tengo que mis test de integración van a funcionar, y asi vamos subiendo.

---

## Pirámide de Pruebas

![Piramide de Pruebas](images/go/piramide.png)

---

## Caja Blanca y Caja Negra

<!-- .slide: style="font-size: 0.80em" -->

- **Test de caja blanca:** Las pruebas de caja blanca (también conocidas como pruebas de caja de cristal o pruebas estructurales) se centran en los detalles procedimentales del software, por lo que su diseño está fuertemente ligado al código fuente.

- **Test de caja negra:** En teoría de sistemas y física, se denomina Caja Negra a aquel elemento que es estudiado desde el punto de vista de las entradas que recibe y las salidas o respuestas que produce, sin tener en cuenta su funcionamiento interno. En otras palabras, de una caja negra nos interesará su forma de interactuar con el medio que le rodea (en ocasiones, otros elementos que también podrían ser cajas negras) entendiendo qué es lo que hace, pero sin dar importancia a cómo lo hace.

---

## Cómo implementar testing en Go

<!-- .slide: style="font-size: 0.75em" -->

- En Go se recomienda definir los casos de prueba respecto de las condiciones que no queremos que ocurran en la ejecución de un módulo de software.
- En aquellos casos donde se busque verificar la consistencia de un valor esperado con una respuesta se puede utilizar una librería externa que permita validar los assert.
- Los tests de caja blanca pueden implementarse en cada uno de los paquetes que contienen los módulos de software a testear. Tienen que ver con funciones, variables, constantes y estructuras privadas.
- Los tests de caja negra pueden implementarse en la carpeta test y tienen que ver con funciones, variables, constantes y estructuras públicas.
- También se pueden implementar benchmarks para medir rendimiento.

---

## Cómo implementar testing en Go

<!-- .slide: style="font-size: 0.80em" -->

Para implementar testing en Go, puedes seguir estos pasos:

- Escribir pequeñas funciones de prueba que ejerciten una única función o método de tu código.
- Ejecutar la prueba usando el comando go test.
- Para generar un reporte con el coverage de tus suites de test, puedes pasar el parámetro adicional -cover.
- Para ejecutar todos los tests dentro del directorio actual y los subdirectorios del mismo, de forma recursiva, puedes pasar el parámetro adicional ./...
- Los archivos de pruebas utilizan el nombre del archivo que se está probando con el sufijo \_test.
- Las funciones que se escriben empiezan con la palabra Test.

---

![Ejemplo Test](images/go/ejemplo_test.png)

---

## Cobertura

<!-- .slide: style="font-size: 0.90em" -->

- La cobertura de código es una medida (porcentual) en las pruebas de software que mide el grado en que el código fuente de un programa ha sido comprobado.
- Sirve para determinar la calidad del test que se lleve a cabo y para determinar las partes críticas del código que no han sido comprobadas y las partes que ya lo fueron, además se puede utilizar como técnica de optimización dentro de un compilador optimizador para llevar a cabo una eliminación de código muerto, más específicamente sirve para detectar código inalcanzable.​

---

## ¿Dudas, Preguntas, Comentarios?

![Preguntas](images/pregunta.gif)

          </textarea>
        </section>
      </div>
    </div>

    <script src="./dist/reveal.js"></script>

    <script src="./mermaid/dist/mermaid.min.js"></script>

    <script src="./plugin/markdown/markdown.js"></script>
    <script src="./plugin/highlight/highlight.js"></script>
    <script src="./plugin/zoom/zoom.js"></script>
    <script src="./plugin/notes/notes.js"></script>
    <script src="./plugin/math/math.js"></script>
    <script>
      function extend() {
        var target = {};
        for (var i = 0; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source) {
            if (source.hasOwnProperty(key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      }

      // default options to init reveal.js
      var defaultOptions = {
        controls: true,
        progress: true,
        history: true,
        center: true,
        transition: 'default', // none/fade/slide/convex/concave/zoom
        slideNumber: true,
        highlight: {
          highlightOnLoad: false
        },
        plugins: [
          RevealMarkdown,
          RevealHighlight,
          RevealZoom,
          RevealNotes,
          RevealMath
        ]
      };

      // options from URL query string
      var queryOptions = Reveal().getQueryHash() || {};

      var options = extend(defaultOptions, {"controls":true,"progress":true,"slideNumber":true,"_":["slides"],"static":"public"}, queryOptions);
    </script>

    <script src="./_assets/slides/js/pruebas.js"></script>
    <script src="./_assets/slides/js/init.js"></script>

    <script>
      Reveal.initialize(options);
      Reveal.addEventListener('ready', function (event) {
        const blocks = Reveal.getRevealElement().querySelectorAll('pre code:not(.mermaid)');
        const hlp = Reveal.getPlugin('highlight');
        blocks.forEach(hlp.highlightBlock);
      });
    </script>

    <script>
      const mermaidOptions = extend({ startOnLoad: false }, {});
      mermaid.startOnLoad = false;
      mermaid.initialize(mermaidOptions);
      const cb = function (event) { mermaid.init(mermaidOptions, '.stack.present>.present pre code.mermaid'); };
      Reveal.addEventListener('ready', cb);
      Reveal.addEventListener('slidetransitionend', cb);
    </script>
  </body>
</html>
